
/*===================================================
功能:仓道<====(iic,ir策略)=====>充电宝
1.策略包括:
  (1)如果指定iic,就只能使用iic通讯
	(2)如果指定ir,就只能使用ir通讯
	(3)两者都可以通讯时，出错几次后切换
	(4)iic单次出错几次后，切换方向，如果再错几次，就应该切换到ir
2.实现方式
  状态机: 可重入，非阻塞
3.功能包括:
  (1)读id
  (2)读数据
  (3)解锁，上锁，解锁1小时,检查输出标志	
4.关于如何使用接口:
  while(channel_read(ch_index,cmd,dataout,timeout)==FALSE){ osdelay(...)}
  等待的时候，cpu被切换，不会影响其它程序的运行	
====================================================*/
#include "includes.h"

/*===================================================
                本地函数
====================================================*/
/*选择策略*/
static READ_TYPE_MODE iic_ir_select_poll(Channel*ch,BOOL error,BOOL clear)
{
	READ_TYPE_MODE mode;
	
	if(clear==TRUE)
	{
		ch->iic_dir_counter=0;
		ch->iic_ir_mode_counter=0;
	}

  if(system.iic_ir_mode==SIIM_ONLY_IR) {return RTM_IR;}	//强制使用 ir		
	if(system.iic_ir_mode==SIIM_ONLY_IIC){mode = RTM_IIC;goto MODE_IIC_POLL;}//强制使用 iic	
	
	if(system.iic_ir_mode==SIIM_IIC_IR)
	{
		mode = (ch->iic_ir_mode);
		if(mode==RTM_IR)        //红外
		{
		  ch->iic_ir_mode_counter+=(error==TRUE)?1:0;
			if(ch->iic_ir_mode_counter>=IR_TO_IIC_SWITCH_ERROR_MAX)//切换错误累加
			{
				ch->iic_ir_mode_counter=0;
				ch->iic_dir_counter=0;
				ch->iic_ir_mode=RTM_IIC;
			}
		}
		else if(mode==RTM_IIC) //IIC
		{
			if(ch->iic_ir_mode_counter>=IIC_TO_IR_SWITCH_ERROR_MAX*2)//切换错误累加
			{
				ch->iic_ir_mode_counter=0;
				ch->iic_dir_counter=0;
				ch->iic_ir_mode=RTM_IR;
			}
			MODE_IIC_POLL:
			ch->iic_dir_counter+=(error==TRUE)?1:0;
			if(ch->iic_dir_counter>=IIC_DIR_SWITCH_MAX)
			{
				ch->iic_dir_counter=0;
				ch->iic_dir=(ch->iic_dir+1)&0x01;
				ch->iic_ir_mode_counter++;
			}
		}
	}
	
	return ch->iic_ir_mode;
}
/*----------------------------------
充电宝操作重定向:是否忙,读 ,是否完成
-----------------------------------*/
static BOOL channel_read_busy(Channel*pch)
{
	U8 ch = channel_data_get_index(pch);
	if(pch->iic_ir_mode == RTM_IIC)return ld_iic_busy(ch);
	if(pch->iic_ir_mode == RTM_IR )return ld_ir_busy (ch);
	return FALSE;
}
static BOOL channel_read_cmd(Channel*pch,U8 cmd)
{
	U8 ch = channel_data_get_index(pch);
	if(pch->iic_ir_mode == RTM_IIC)return ld_iic_cmd(ch,cmd);
	if(pch->iic_ir_mode == RTM_IR )return ld_ir_cmd(ch,cmd);
	return FALSE;
}

static BOOL channel_read_start(Channel*pch,READ_TYPE_CMD cmd)
{
	U8 wanlen=0;
	U8 ch = channel_data_get_index(pch);
	if(pch->iic_ir_mode == RTM_IIC)
	{
		switch(cmd)
		{
			case RC_READ_ID:wanlen=10;break;
			case RC_READ_DATA:wanlen=13;break;
			case RC_OUTPUT:wanlen=1;break;
			case RC_LOCK:case RC_UNLOCK: case RC_UNLOCK_1HOUR: wanlen=0;break;
			default: return FALSE;
		}
		return ld_iic_read_start(ch,pch->iic_dir, cmd,wanlen);
	}
	else if(pch->iic_ir_mode ==RTM_IR){
		switch(cmd)
		{
			case RC_READ_ID:wanlen=7;break;
			case RC_READ_DATA:wanlen=13;break;
			case RC_OUTPUT:return FALSE;
			case RC_LOCK:case RC_UNLOCK: case RC_UNLOCK_1HOUR: wanlen=2;break;
			default: return FALSE;
		}
		return ld_ir_read_start(ch,pch->iic_dir, cmd,wanlen);
	}
	else return FALSE;
}

static int channel_read_end(Channel*pch,U8*dataout)
{
	U8 wanlen=0;
	U8 ch = channel_data_get_index(pch);
	if(pch->iic_ir_mode == RTM_IIC)
	{
		return ld_iic_read_isok(ch,dataout,0);
	}
	else if(pch->iic_ir_mode ==RTM_IR){
		return ld_ir_read_isok(ch,dataout,0);
	}
	else return 2;
}

/*===================================================
                充电宝读状态机 
返回:  
state: 当前状态[input]
   初始值=0;
0:本命令未开始
1:本命令在运行 
2:本命令成功  
3:本命令无法读取
4:超时记错一次
====================================================*/
U8 channel_read(Channel*pch,READ_TYPE_CMD cmd,U8*dataout)
{
	#define s (pch->cmd_state)
	U8 ch = channel_data_get_index(pch);
	
	//命令未运行
	if(s==0)
	{
		//非本命令在运行
		if(channel_read_busy(pch)) return s;
		else
		{
			if(channel_read_start(pch,cmd)==FALSE)
			{
				goto CHANNEL_READ_ERROR;
			}
			else {pch->thread=PROCESS_CURRENT();s =1;return 1;}
		}
	}
	//本命令已经开始
	if(s==1)
	{
		if( channel_read_busy(pch) && channel_read_cmd(pch,cmd) && (pch->thread==PROCESS_CURRENT())){return 1;}
		{
			int err= channel_read_end(pch,dataout);
		  if(err<0)//本命令失败
			{
				goto CHANNEL_READ_ERROR;
			}          
		  else if(err==2)//本命令成功
			{
				s=0;
				iic_ir_select_poll(pch,FALSE,TRUE);
				return 2;
			} 
	  }
	}
	
	if(s>=2)
	{
		//超时
		if(s==4){			
			CHANNEL_READ_ERROR:
				iic_ir_select_poll(pch,TRUE,FALSE);//记错一次
			  pch->thread=0;
		}
		s=0;
    return 3;	
	}
}