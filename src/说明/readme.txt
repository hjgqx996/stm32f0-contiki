==========================================================================
工程  : stm32f0-contiki     固件程序
        pcb_test            PCB板厂 对于输出的测试程序
==========================================================================
==========================================================================
						文档结构
		生成的镜像文件在 ./生成/xxxxx.hex  xxxxx.bin
		命令规则是:  pcb名称-硬件编号-软件编号
		eg:LD-MZ-DRIVER-5-A-V6-0203-0001.hex
==========================================================================

+app----+              //任务类      
|    	+thread_insert.c  充电任务   
|    	+thread_comm.c    通讯任务  
|    	+thread_channel.c 仓道任务(读数据，状态检测，错误处理)   
|    	+thread_eject.c   锁仓事件  
|    	+main.c       主程序
|       +config.c     应用层配置(常量)
|       +config.h     应用层参数配置(可视化配置)
|
|
+system-+              //非任务，功能操作
|       |
|       +channel.c        与仓道操作相关(数据，地址，状态，灯....)
|	    +channel_read.c   读充电宝操作(1.统一iic与ir 标准化接口  2.接口使用阻塞方式 3.包含iir,ir的选择策略)  
|	    +queue.c          充电排队算法(保证  【一个电量为0  + 一个电量不为0】  的充电宝先充，其它挂起)
|       +packet.c         485通讯的 接收 发送 
|	    +system.c         系统参数读写，系统灯
|
+contiki:+            //非抢占式 内核
|        |
|        +autostart.c      自动运行相关
|        +etimer.c         事件定时器
|        +process.c        任务，调度，事件，延时 相关
|        +timer.c          定时器
|
+portable:+           //内核移植 clock
|         |
|         +clodk.c      时钟(contiki以时钟滴答来驱动)
|	  
+dev:----+            //底层驱动模型
|        |
|        +driver_config.c      底层驱动配置文件
|        +dev.c                初始化，重定向文件
|        +gpio.c               io
|        +iic.c                iic + bq27541 + 标准化接口 (三部分程序)
|        +uart.c               串口驱动
|        +ir.c                 红外，使用定时器方式
|        +74hc595.c            扩展io
|        +timer.c              片内定时器
|        +exti.c               外部中断
|	 
+cpu:               stm32f0xx标准库
+lib:               库函数
|
|//输出文件
+生成               xxxxxx.bin   xxxxxxx.hex
|
|//帮助文件
+说明:
|     readme.txt    本文件

==========================================================================
				线程的自动启动
==========================================================================
1.修饰宏:定义一个线程，它自动启动
#define AUTOSTART_THREAD_WITH_TIMEOUT(name)     //带延时变量
#define AUTOSTART_THREAD_WITHOUT_TIMEOUT(name)  //不带延时变量

2.实现原理:
  使用  AUTOSTART_PROCESSES(thread_##name);
        它包含了  __attribute__((section("autostart")))
  ===》所有线程被定位到了  autostart 段
 
3.main函数使用 process_start(&etimer_process,NULL); //启动 
  启动所有线程

==========================================================================
                 iic 与  ir 接口的 统一
==========================================================================
1.ir 实现:
			(1) ld_ir_timer_100us   用于100us产生时序
			(2) ld_ir_read_start	启动一次传输
			(3) ld_ir_read_isok		查询传输是否完成

2.iic 实现:
              (1)读id 			ld_bq27541_read_id_start-------------->延时50ms(状态机释放cpu)---->ld_bq27541_read_id_end
              (2)读数据         ld_bq27541_read_words
              (3)加解密         ld_bq27541_de_encrypt_charge_start---->延时50ms(状态机释放cpu)---->ld_bq27541_de_encrypt_charge_end
              (4)读输出         ld_bq27541_output_flag
			  
   状态机实现(线程不断运行)
              (1) ld_iic_read_start 启动一次传输
			  (2) ld_iic_read_isok	查询传输是否完成

3.接口统一
channel_read:
  
  (1) 根据模式 启动(iir or ir)
  (2) 一次调用查询是否完成
  (3) 产生结果时=============>选择策略====>产生下一次的模式
  
==========================================================================
                 iic 与  ir 选择策略
==========================================================================
1.策略包括:
			(1)如果指定iic,就只能使用iic通讯
			(2)如果指定ir,就只能使用ir通讯
			(3)两者都可以通讯时，出错几次后切换
			(4)在使用iic时:出错几次后，切换方向，如果再错几次，就应该切换到ir
			(5)当前是ir时,每3个循环读一次iic,如果iic成功，切换到iic
			   如果连接3次读iic失败，就不会再检测iic,之后时间一直使用ir读
==========================================================================
                 任务描述
==========================================================================
1.thread_insert   :充电流程
2.thread_comm     :上行协议,包括5个任务
									数据包解析:packet
									租借任务:comm_lease
									控制任务:comm_ctrl
									进入固件:comm_entry
									异步归还:return

3.thread_channel  :循环读数据,红外检测
4.thread_eject    :弹仓事件
5.queue           :排队调度任务
==========================================================================
                 排队算法(queue)
==========================================================================
1. 5 秒 10分钟中的 先充===>有且只有一个
2. 其它的按电量排队，

如有两个 5秒充电,其余7小时内充电，排队为:
                        [hard][电量][电量][电量][hard]
						 充电  充电  排队  排队  排队
排队期间，充电流程计时挂起 


3.新增强制充电:
               当强制充电时     : 排队算法被挂起，不调度
               当强制充电无效时 : 排队算法恢复，重新调度
			   强制充电由:System{enable mode chs} 三个变量控制
==========================================================================
                 充电流程
==========================================================================
 严格按照 <通道给充电宝充电的逻辑.pdf> 流程控制	
==========================================================================
                 仓道数据被清0的几种情况 
==========================================================================
1.充电宝读几次失败，      数据清0
2.运维 或 强制 弹仓 成功  数据清0
3.租借成功                数据清0
4.摆臂开关无效            数据清0
==========================================================================
                 串口数据包
==========================================================================
接收中断-->packet_recv(返回一个有效包),post给thread_packet任务

-->处理命令-->中断发送响应包
==========================================================================
                 功耗说明 
==========================================================================
1.无红外，无iic ====> 22mA(16Mhz)   55mA(48Mhz)
本程序使用:24Mhz

==========================================================================
                 硬件问题
==========================================================================
1.充电宝进入时，对5V产生干扰，导致 exti 中断有误，
  为了减成本，没有在5V的地方添加电容
  解决办法:
            就算有干扰也读一次充电宝，但是数据不清0
			（之前的版本是:充电宝进入会清0数据）
			
2.在channel_read 中打印红外故障时，会引起 hardfault应该是 缓冲数据没有处理好